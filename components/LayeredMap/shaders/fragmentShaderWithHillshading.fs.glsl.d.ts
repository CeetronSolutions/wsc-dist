declare const fragmentShader = "// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at https://mozilla.org/MPL/2.0/.\n//\n// Copyright (C) 2020 - Equinor ASA.\n\nprecision mediump float;\n\nuniform sampler2D u_image;\nuniform sampler2D u_colormap_frame;\nuniform vec2 u_resolution_fragment;\nuniform float u_colormap_length;\nuniform float u_elevation_scale;\nuniform vec3 u_light_direction;\n\nvarying vec2 v_texCoord;\n\nvoid main() {\n    vec2 pixelPos = vec2(gl_FragCoord.x, u_resolution_fragment.y - gl_FragCoord.y);\n\n    float v0 = texture2D(u_image, pixelPos / u_resolution_fragment).r;\n    float vx = texture2D(u_image, (pixelPos + vec2(1.0, 0.0)) / u_resolution_fragment).r;\n    float vy = texture2D(u_image, (pixelPos + vec2(0.0, 1.0)) / u_resolution_fragment).r;\n\n    // Create tangent vector components along terrain\n    // in x and y directions respectively:\n    vec3 dx = vec3(u_elevation_scale, 0.0, vx - v0);\n    vec3 dy = vec3(0.0, u_elevation_scale, v0 - vy);\n\n    // Calculate terrain normal vector by taking cross product of dx and dy.\n    // Then calculate simple hill shading by taking dot product between\n    // normal vector and light direction vector.\n    float light = 0.5 * dot(normalize(cross(dx, dy)), u_light_direction) + 0.5;\n\n    float map_array = texture2D(u_image, v_texCoord).r;\n    vec4 color = texture2D(u_colormap_frame, vec2((map_array * (u_colormap_length - 1.0) + 0.5) / u_colormap_length, 0.5));\n\n    gl_FragColor = color * vec4(light, light, light, 1.0);\n}";
export default fragmentShader;
