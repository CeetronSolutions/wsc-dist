declare const terrainRgbFs = "// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at https://mozilla.org/MPL/2.0/.\n//\n// Copyright (C) 2020 - Equinor ASA.\n\nprecision highp float;\n\nconst int INTERP_LINEAR = 0;\nconst int INTERP_LOG    = 1;\n\nuniform sampler2D u_data_texture;\nuniform vec2 u_resolution;\n\nuniform sampler2D u_colormap;\nuniform int u_interpolation_type;\nuniform float u_value_range;\nuniform vec2 u_remap_colormap;\nuniform vec2 u_clamp_colormap;\n\nuniform bool u_apply_color_scale;\nuniform bool u_apply_hillshading;\n\nuniform vec3 u_sun_direction;\nuniform float u_ambient_light_intensity;\nuniform float u_diffuse_light_intensity;\n\nuniform float u_elevation_scale;\n\n// TODO: Investigate using R32 textures (webgl2) to avoid this transformation.\nfloat elevation_from_rgb(vec3 col) {\n    // Decode elevation data. Format is similar to the Mapbox Terrain RGB:\n    // https://docs.mapbox.com/help/troubleshooting/access-elevation-data/\n    // but without the -10000 offset and the 0.1 scale.\n    // The elevations are also scaled to cover the whole RGB domain, for better precision,\n    // so we need to scale them down to the original domain.\n    float elevation = col.r * 255.0 * 256.0 * 256.0 + col.g * 255.0 * 256.0 + col.b * 255.0 ;\n    float scale_factor = u_value_range / (256.0*256.0*256.0 - 1.0);\n    return elevation * scale_factor *  u_elevation_scale;\n}\n\nvec4 color_map(float elevation) {\n    float colormap_u = 0.0;\n    if (u_interpolation_type == INTERP_LOG) {\n        // Add one to avoid log(0). The result should be the same.\n        colormap_u = log(elevation + 1.0) / log(u_value_range + 1.0);\n    }\n    else { // u_interpolation_type == INTERP_LINEAR\n        colormap_u = elevation / u_value_range;\n    }\n\n    // Cutoff\n    if (colormap_u < u_clamp_colormap.x || colormap_u > u_clamp_colormap.y) {\n        discard;\n    }\n\n    // Remap\n    colormap_u = mix(u_remap_colormap.x, u_remap_colormap.y, colormap_u);\n\n    return texture2D(u_colormap, vec2(colormap_u, 0.0));\n}\n\nvec3 normal(float elevation) {\n    vec2 dr = 1.0/u_resolution;\n    float p0 = elevation;\n    float px = elevation_from_rgb(texture2D(u_data_texture, dr * (gl_FragCoord.xy + vec2(1.0, 0.0))).rgb);\n    float py = elevation_from_rgb(texture2D(u_data_texture, dr * (gl_FragCoord.xy + vec2(0.0, 1.0))).rgb);\n    vec3 dx = vec3(1.0, 0.0, px - p0);\n    vec3 dy = vec3(0.0, 1.0, py - p0);\n\n    return normalize(cross(dx, dy));\n}\n\nfloat light(vec3 normal) {\n    float diffuse = u_diffuse_light_intensity * dot(normal, u_sun_direction);\n\n    return clamp(u_ambient_light_intensity + diffuse, 0.0, 1.0);\n}\n\nvoid main() {\n    vec4 final_color = texture2D(u_data_texture, gl_FragCoord.xy/u_resolution);\n\n    if (final_color.a == 0.0) {\n        discard;\n    }\n\n    float elevation = elevation_from_rgb(final_color.rgb);\n\n    if (u_apply_color_scale) {\n        // The colorscale shouldn't be affected by the elevation scale.\n        final_color = color_map(elevation / u_elevation_scale);\n    }\n\n    if (u_apply_hillshading) {\n        vec3 normal = normal(elevation);\n        final_color.rgb = final_color.rgb * light(normal);\n    }\n\n    gl_FragColor = final_color;\n}";
export default terrainRgbFs;
