declare const fsShader = "#version 300 es\n#define SHADER_NAME terrainmap-shader\n\nprecision highp float;\n\n\nuniform bool isContoursDepth;\nuniform float contourReferencePoint;\nuniform float contourInterval;\n\nin vec2 vTexCoord;\nin vec3 cameraPosition;\nin vec3 normals_commonspace;\nin vec4 position_commonspace;\nin vec4 vColor;\n\nflat in int vertex_indexs_;\n\nout vec4 fragColor;\n\nin vec3 worldPos;\nin float property;\n\nuniform sampler2D colormap;\n\nuniform float valueRangeMin;\nuniform float valueRangeMax;\nuniform float colorMapRangeMin;\nuniform float colorMapRangeMax;\n\nuniform vec3 colorMapClampColor;\nuniform bool isClampColor;\nuniform bool isColorMapClampColorTransparent;\nuniform bool smoothShading;\n\n\nvoid main(void) {\n   geometry.uv = vTexCoord;\n\n   vec3 normal = normals_commonspace;\n\n   if (!smoothShading) {\n      normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\n   } \n\n   // // Discard transparent pixels. KEEP\n   // if (!picking_uActive && isnan(propertyValue)) {\n   //    discard;\n   //    return;\n   // }\n   \n   //Picking pass.\n   if (picking_uActive) {\n      // Express triangle index in 255 system.\n      float r = 0.0;\n      float g = 0.0;\n      float b = 0.0;\n  \n      int idx = vertex_indexs_;\n  \n      if (idx >= (256 * 256) - 1) {\n         r = floor(float(idx) / (256.0 * 256.0));\n         idx -= int(r * (256.0 * 256.0));\n      }\n  \n      if (idx >= 256 - 1) {\n         g = floor(float(idx) / 256.0);\n         idx -= int(g * 256.0);\n      }\n  \n      b = float(idx);\n  \n      fragColor = vec4(r / 255.0, g / 255.0, b / 255.0,  1.0);\n      return;\n   }\n\n   vec4 color = vec4(1.0, 1.0, 1.0,  1.0);;\n   float propertyValue = property;\n\n   float x = (propertyValue - colorMapRangeMin) / (colorMapRangeMax - colorMapRangeMin);\n   if (x < 0.0 || x > 1.0) {\n      // Out of range. Use clampcolor.\n      if (isClampColor) {\n         color = vec4(colorMapClampColor.rgb, 1.0);\n\n      }\n      else if (isColorMapClampColorTransparent) {\n         discard;\n         return;\n      }\n      else {\n         // Use min/max color to clamp.\n         x = max(0.0, x);\n         x = min(1.0, x);\n\n         color = texture2D(colormap, vec2(x, 0.5));\n      }\n   }\n   else {\n      color = texture2D(colormap, vec2(x, 0.5));\n   }\n\n  \n   bool is_contours = contourReferencePoint != -1.0 && contourInterval != -1.0;\n   if (is_contours) {\n      // Contours are made of either depths or properties.\n      float val = isContoursDepth ? (abs(worldPos.z) - contourReferencePoint) / contourInterval\n                                  : (propertyValue - contourReferencePoint) / contourInterval;\n\n      float f  = fract(val);\n      float df = fwidth(val);\n\n      // keep: float c = smoothstep(df * 1.0, df * 2.0, f); // smootstep from/to no of pixels distance fronm contour line.\n      float c = smoothstep(0.0, df * 2.0, f);\n\n      color = color * vec4(c, c, c, 1.0);\n   }\n\n   // Use normal lighting. This has no effect if \"material\" property is not set.\n   vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);\n   fragColor = vec4(lightColor, 1.0);\n\n   DECKGL_FILTER_COLOR(fragColor, geometry);\n}\n";
export default fsShader;
