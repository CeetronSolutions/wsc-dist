declare const fsShader = "#version 300 es\n#define SHADER_NAME terrainmap-shader\n\nprecision highp float;\n\n\nuniform bool isContoursDepth;\nuniform float contourReferencePoint;\nuniform float contourInterval;\n\nin vec2 vTexCoord;\nin vec3 cameraPosition;\nin vec3 normals_commonspace;\nin vec4 position_commonspace;\nin vec3 worldPos;\nin float property;\n\nout vec4 fragColor;\n\nuniform sampler2D colormap;\nuniform vec4 uColor;\nuniform bool smoothShading;\n\n\nvoid main(void) {\n   //geometry.uv = vTexCoord;\n\n   vec3 normal = normals_commonspace;\n\n   if (!smoothShading) {\n      normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\n   } \n   \n   //Picking pass.\n   if (picking_uActive) {\n      // Readout is surface height (z value).\n      float range = 10000.0;  // May represent depths in range 0 - 10000 meter.\n\n      // Express in 255 system.\n      float depth = abs(worldPos.z);\n      float depthScaled = (256.0 * 256.0 * 256.0) * (depth / range); // scaled to within max range in 256 system.\n\n      float r = 0.0;\n      float g = 0.0;\n      float b = 0.0;\n\n      if (depthScaled >= (256.0 * 256.0) - 1.0) {\n         r = floor(depthScaled / (256.0 * 256.0));\n         depthScaled -= r * (256.0 * 256.0);\n      }\n\n      if (depthScaled >= 256.0 - 1.0) {\n         g = floor(depthScaled / 256.0);\n         depthScaled -= g * 256.0;\n      }\n\n      b = floor(depthScaled);\n\n      fragColor = vec4(r / 255.0, g / 255.0, b / 255.0,  1.0);\n      return;\n   }\n\n   vec4 color = uColor;\n\n   bool is_contours = contourReferencePoint != -1.0 && contourInterval != -1.0;\n   if (is_contours) {\n      // Contours are made of either depths or properties.\n      float val = (abs(worldPos.z) - contourReferencePoint) / contourInterval;\n\n      float f  = fract(val);\n      float df = fwidth(val);\n\n      // keep: float c = smoothstep(df * 1.0, df * 2.0, f); // smootstep from/to no of pixels distance fronm contour line.\n      float c = smoothstep(0.0, df * 2.0, f);\n\n      color = color * vec4(c, c, c, 1.0);\n   }\n\n   // Use normal lighting. This has no effect if \"material\" property is not set.\n   vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);\n   fragColor = vec4(lightColor, 1.0);\n\n   DECKGL_FILTER_COLOR(fragColor, geometry);\n}\n";
export default fsShader;
