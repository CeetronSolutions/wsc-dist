declare const fsHillshading = "#define SHADER_NAME hillshading2d-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nvarying vec2 vTexCoord;\n\nuniform sampler2D bitmapTexture; // Property map\nuniform vec2 bitmapResolution;\n\nuniform float valueRangeSize;\n\nuniform vec3 lightDirection;\nuniform float ambientLightIntensity;\nuniform float diffuseLightIntensity;\nuniform float opacity;\n\n// Compute the normal value for every pixel, based on the current value and two values aroud it.\nvec3 normal(float val) {\n  vec2 dr = 1.0 / bitmapResolution;\n  float p0 = valueRangeSize * val;\n  float px = valueRangeSize * decode_rgb2float(texture2D(bitmapTexture, vTexCoord + vec2(1.0, 0.0) / bitmapResolution).rgb);\n  float py = valueRangeSize * decode_rgb2float(texture2D(bitmapTexture, vTexCoord + vec2(0.0, 1.0) / bitmapResolution).rgb);\n  vec3 dx = vec3(1.0, 0.0, px - p0);\n  vec3 dy = vec3(0.0, 1.0, py - p0);\n\n  return normalize(cross(dx, dy));\n}\n\n// Compute how much a pixel is in the shadow based on its normal and where the light comes from.\nfloat shadow(vec3 normal) {\n  float diffuse = diffuseLightIntensity * dot(normal, normalize(lightDirection));\n  return clamp(ambientLightIntensity + diffuse, 0.0, 1.0);\n}\n\nvoid main(void) {\n  vec4 bitmapColor = texture2D(bitmapTexture, vTexCoord);\n\n  // If it's a picking pass, we just return the raw property map value.\n  if (picking_uActive) {\n    gl_FragColor = bitmapColor;\n    return;\n  }\n\n  // Decode the RGB value into a float. See decoder.fs.glsl for more details.\n  float val = decode_rgb2float(bitmapColor.rgb);\n  // Compute the shadow value, how dark a pixel will be, 1 is in complete shadow, 0 is in complete light.\n  float shadow = shadow(normal(val));\n\n  // The final pixel is black, with the opacity based on the shadow value,\n  // opacity 0 if pixel is completely in the light, opacity 1 if pixel is completely in the shadow.\n  // The property map opacity (some portions of the property map can be transparent) and\n  // the user provided image-wide opacity value are also taken into account.\n  gl_FragColor = vec4(vec3(0.0), (1.0-shadow) * bitmapColor.a * opacity);\n\n  geometry.uv = vTexCoord;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
export default fsHillshading;
